#generated, do not edit manually!
schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

#generated, do not edit manually!
interface Attribute {
    id: ID!
    name: String!
}

#generated, do not edit manually!
type StringAttribute implements Attribute {
    id: ID!
    name: String!
    string: String!
}

#generated, do not edit manually!
type BooleanAttribute implements Attribute {
    id: ID!
    name: String!
    boolean: Boolean!
}

#generated, do not edit manually!
type ReferenceAttribute implements Attribute {
    id: ID!
    name: String!
    ref: ID!
}

#generated, do not edit manually!
type FloatAttribute implements Attribute {
    id: ID!
    name: String!
    float: Float!
}

#generated, do not edit manually!
type DateTimeAttribute implements Attribute {
    id: ID!
    name: String!
    dateTime: AWSDateTime!
}

#generated, do not edit manually!
type TupleAttribute implements Attribute {
    id: ID!
    name: String!
    tuple: AWSJSON!
}

#generated, do not edit manually!
type MultiStringAttribute implements Attribute {
    id: ID!
    name: String!
    strings: [String!]!
}

#generated, do not edit manually!
type MultiBooleanAttribute implements Attribute {
    id: ID!
    name: String!
    booleans: [Boolean!]!
}

#generated, do not edit manually!
type MultiReferenceAttribute implements Attribute {
    id: ID!
    name: String!
    refs: [ID!]!
}

#generated, do not edit manually!
type MultiFloatAttribute implements Attribute {
    id: ID!
    name: String!
    floats: [Float!]!
}

#generated, do not edit manually!
type MultiDateTimeAttribute implements Attribute {
    id: ID!
    name: String!
    dateTimes: [AWSDateTime!]!
}

#generated, do not edit manually!
type MultiTupleAttribute implements Attribute {
    id: ID!
    name: String!
    tuples: [AWSJSON!]!
}

#generated, do not edit manually!
type PageInfo {
    size: Int!
    first: Int!
    prev: Int
    current: Int!
    next: Int
    last: Int!
}

#generated, do not edit manually!
input PageQuery {
    number: Int = 0
    size: Int = 20
}

#generated, do not edit manually!
input EntityFilter {
    attributes: [ID!]
}

#generated, do not edit manually!
type Query {
    getEntity(id: ID!): Entity
    listEntity(page: PageQuery, filter: EntityFilter): EntityListPage!
    getDataPoint(id: ID!): DataPoint
    getPlanetaryBoundary(id: ID!): PlanetaryBoundary
    getQuantification(id: ID!): Quantification
    listDataPoint(page: PageQuery): DataPointListPage!
    listPlanetaryBoundary(page: PageQuery): PlanetaryBoundaryListPage!
    listQuantification(page: PageQuery): QuantificationListPage!
}

#generated, do not edit manually!
type Entity {
    id: ID!
    attributes: [Attribute!]!
}

#generated, do not edit manually!
interface EntityBase {
    id: ID!
}

#generated, do not edit manually!
type DataPoint implements EntityBase {
    id: ID!
    quantifications: [Quantification!]
    value: Float
}

#generated, do not edit manually!
type PlanetaryBoundary implements EntityBase {
    id: ID!
    description: String
    name: String
    quantifications: [Quantification!]
}

#generated, do not edit manually!
type Quantification implements EntityBase {
    id: ID!
    dataPoints: [DataPoint!]
    name: String
    planetaryBoundaries: [PlanetaryBoundary!]
}

#generated, do not edit manually!
type EntityListPage {
    info: PageInfo!
    values: [Entity!]!
}

#generated, do not edit manually!
type DataPointListPage {
    info: PageInfo!
    values: [DataPoint!]!
}

#generated, do not edit manually!
type PlanetaryBoundaryListPage {
    info: PageInfo!
    values: [PlanetaryBoundary!]!
}

#generated, do not edit manually!
type QuantificationListPage {
    info: PageInfo!
    values: [Quantification!]!
}

#generated, do not edit manually!
input DataPointInput {
    id: ID!
    quantifications: [QuantificationInput!]
    value: Float
}

#generated, do not edit manually!
input PlanetaryBoundaryInput {
    id: ID!
    description: String
    name: String
    quantifications: [QuantificationInput!]
}

#generated, do not edit manually!
input QuantificationInput {
    id: ID!
    dataPoints: [DataPointInput!]
    name: String
    planetaryBoundaries: [PlanetaryBoundaryInput!]
}

#generated, do not edit manually!
type Mutation {
    publishCreatedDataPoint(value: DataPointInput!): DataPoint
    publishCreatedPlanetaryBoundary(value: PlanetaryBoundaryInput!): PlanetaryBoundary
    publishCreatedQuantification(value: QuantificationInput!): Quantification
    publishUpdatedDataPoint(value: DataPointInput!): DataPoint
    publishUpdatedPlanetaryBoundary(value: PlanetaryBoundaryInput!): PlanetaryBoundary
    publishUpdatedQuantification(value: QuantificationInput!): Quantification
    publishDeletedDataPoint(value: DataPointInput!): DataPoint
    publishDeletedPlanetaryBoundary(value: PlanetaryBoundaryInput!): PlanetaryBoundary
    publishDeletedQuantification(value: QuantificationInput!): Quantification
    createDataPoint(value: DataPointInput!): DataPoint!
    createPlanetaryBoundary(value: PlanetaryBoundaryInput!): PlanetaryBoundary!
    createQuantification(value: QuantificationInput!): Quantification!
    mergeDataPoint(value: DataPointInput!): DataPoint
    mergePlanetaryBoundary(value: PlanetaryBoundaryInput!): PlanetaryBoundary
    mergeQuantification(value: QuantificationInput!): Quantification
    deleteDataPoint(id: ID!): DataPoint
    deletePlanetaryBoundary(id: ID!): PlanetaryBoundary
    deleteQuantification(id: ID!): Quantification
}

#generated, do not edit manually!
type Subscription {
    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onCreatedDataPoint(id: ID, value: Float): DataPoint
    @aws_subscribe(mutations: ["publishCreatedDataPoint"])

    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onCreatedPlanetaryBoundary(id: ID, description: String, name: String): PlanetaryBoundary
    @aws_subscribe(mutations: ["publishCreatedPlanetaryBoundary"])

    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onCreatedQuantification(id: ID, name: String): Quantification
    @aws_subscribe(mutations: ["publishCreatedQuantification"])

    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onUpdatedDataPoint(id: ID, value: Float): DataPoint
    @aws_subscribe(mutations: ["publishUpdatedDataPoint"])

    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onUpdatedPlanetaryBoundary(id: ID, description: String, name: String): PlanetaryBoundary
    @aws_subscribe(mutations: ["publishUpdatedPlanetaryBoundary"])

    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onUpdatedQuantification(id: ID, name: String): Quantification
    @aws_subscribe(mutations: ["publishUpdatedQuantification"])

    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onDeletedDataPoint(id: ID, value: Float): DataPoint
    @aws_subscribe(mutations: ["publishDeletedDataPoint"])

    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onDeletedPlanetaryBoundary(id: ID, description: String, name: String): PlanetaryBoundary
    @aws_subscribe(mutations: ["publishDeletedPlanetaryBoundary"])

    "Reminder: A `null` argument will filter the result differently than omitting the argument entirely."
    onDeletedQuantification(id: ID, name: String): Quantification
    @aws_subscribe(mutations: ["publishDeletedQuantification"])
}

